# ğŸ’» 16-bit CPU based on Finite State Machine (FSM)

## ğŸ“Œ 1. Project Overview

This project implements a custom **16-bit Central Processing Unit (CPU)** entirely described in **VHDL**, intended for FPGA implementation (using Vivado). The architecture uses a **Finite State Machine (FSM)** to control the Fetch-Execute cycle, allowing instructions to be executed over **multiple clock cycles** (multicycle architecture).

---

## ğŸ—ï¸ 2. CPU Architecture

### 2.1 Instruction Set Architecture (ISA)

* **Instruction Width:** 16 bits.
* **Base Format:** `[Unused/Reg2] [Reg1] [Opcode]` (16 bits)
    * **Opcode (bits 0-3):** Defines the operation (e.g., `LOAD`, `ADD`).
    * **Reg1 (bits 4-7):** Typically the register referenced by the specified operation (e.g., `LOAD`, `ADD`).
    * **Reg2 (bits 8-11):** Typically used as the **Destination** register for `MOVE` or `ADDR`. Ignored for immediate operations.

| Opcode (Binary) | Hex | Name | Function |
| :---: | :---: | :---: | :--- |
| `0000` | 0 | **FETCH** | Do nothing |
| `0001` | 1 | **STORE** | Stores the content of a Register into Memory. |
| `0010` | 2 | **LOAD** | Loads an Immediate Value into a Register. |
| `0011` | 3 | **LOADM** | Loads a value from Memory into a Register (Indirect). |
| `0100` | 4 | **ADD** | Adds an Immediate Value to a Register. |
| `0101` | 5 | **SUB** | Subtracts an Immediate Value from a Register. |
| `0110` | 6 | **JUMPZ** | Jumps to LABEL if the Z (Zero) Flag is high. |
| `0111` | 7 | **JUMPNZ**| Jumps to LABEL if the NZ (Non-Zero) Flag is high. |
| `1000` | 8 | **COMPARE** | Compares two Registers and updates the Condition Flags. |
| `1001` | 9 | **LABEL** | Defines a jump point (saves the PC address). |
| `1010` | A | **ADDR** | Addition between two Registers (`Rx = Rx + Ry`). |
| `1011` | B | **SUBR** | Subtraction between two Registers (`Rx = Rx - Ry`). |
| `1100` | C | **MOVE** | Moves the value from one Register to another (`Rx = Ry`). |

### 2.2 Register File

The register set consists of **6 general-purpose 16-bit registers** (`RX`, `RY`, `RZ`, `RA`, `RB`, `RC`).

| Register | Identifier (Binary) |
| :---: | :---: |
| **RX** | `0000` |
| **RY** | `0001` |
| **RZ** | `0010` |
| **RA** | `0011` |
| **RB** | `0100` |
| **RC** | `0101` |

### 2.3 Condition Flags

The CPU manages four condition flags that are updated by `COMPARE` instructions and used by jump instructions.

* **Z (Zero):** Set if the result of the last operation is zero.
* **NZ (Non-Zero):** Set if the result is not zero.
* **N (Negative):** Set if the result is negative.
* **P (Positive):** Set if the result is positive.

---

## âš™ï¸ 3. Finite State Machine (FSM) - Control Logic

The FSM is the core of the CPU, managing the multicycle instruction execution flow.

### 3.1 Main States (Execution Phases)

The FSM operates on a multicycle logic, controlled by the following states:

| VHDL State | Description | Function |
| :---: | :--- | :--- |
| `init` | Initialization | Resets all registers and the Program Counter (PC). |
| `execute` | **Fetch & Decode** | Fetches the instruction in `DATA_IN`, decodes it, and sets control flags. |
| `wait_address` | Memory Management (Phase 1) | Waits for the address to be used (`STORE` or `LOADM`). |
| `wait_data` | ALU Management (Immediate) | Sends the immediate operand to the ALU (also handles one's complement for subtraction). |
| `write_reg` | Write-Back | Writes the final result (ALU/Memory/Data) to the destination register. |
| `write_mem` | Memory Write | Dedicated cycle for sending the data onto the data bus for the `STORE` operation. |
| `compare` | Flag Update | Dedicated cycle for updating the condition flags. |
| `wait_generic` | Synchronization | Transition state used to keep control signals active during delays. |

### 3.2 Signal Persistence (The Multicycle Secret)

The key to the correct execution sequence in this architecture is the **persistence of control signals** (`flag_alu`, `flag_sub`, `flag_reg`).

These flags are implemented as registers within the FSM and are **cleared only at the beginning of the `execute` state**. This mechanism ensures that the `write_reg` state (which occurs several cycles later) "remembers" whether it should write a result coming from the **ALU** (`ALU_REG`) or a value read from Memory (`DATA_IN`).

---

## ğŸ“‚ 4. File Structure

The main files of the project are:

* `FSM.vhd`: Contains the Finite State Machine (FSM) that controls the flow, cache registers, and the PC.
* `cpu_defs.vhd`: Package containing all Opcode constants and Register definitions (e.g., `RX`, `FLAG_RX`).
* `ALU.vhd`
* `blk_mem_gen_0.vhd`: The RAM module to hold the instructions.
* `TOP_CPU.vhd`: Integrates the FSM, ALU, and Memory.
* `.gitignore`: **Crucial** for ignoring all log, synthesis, and simulation files generated by Vivado.

---

## ğŸ› ï¸ 5. Usage and Testing

1.  Clone the repository:
    ```bash
    git clone [URL]
    ```
2.  Open the project in **Vivado**.
3.  Simulate the `TOP_CPU_tb.vhd` file to observe the correct state transitions.
4.  Synthesize for the target FPGA platform (specify the board).

---

## ğŸ§ 6. Example Opcodes

| Address (Hex) | Opcode | Operand / Data (Hex) | Detailed Description |
| :---: | :--- | :--- | :--- |
| **0012** | `OP_LOAD` | `Ry` | Loads an immediate value into register `Ry` (Memory Data Register). |
| **00AF** | (Data) | `0x00AF` | Immediate value: **175** (decimal). Result: `Ry` = 175. |
| **0011** | `OP_STORE` | `Ry` | Stores the content of `Ry` into Memory. |
| **0650** | (Data) | `0x0650` | Memory address. Result: `MEM[0x0650]` = 175. |
| **0023** | `OP_LOADM` | `Rz` | Loads a value fetched from memory into register `Rz`. |
| **0650** | (Data) | `0x0650` | Reads from address 0x0650. Result: `Rz` = 175. |
| **021A** | `OP_ADDR` | `Ry, Rz` | Register Addition: `Ry` = `Ry + Rz`. (175 + 175 = **350**). |
| **021B** | `OP_SUBR` | `Ry, Rz` | Register Subtraction: `Ry` = `Ry - Rz`. (350 - 175 = **175**). |
| **0014** | `OP_ADD` | `Ry` | Immediate addition to register `Ry`. |
| **0016** | (Data) | `0x0016` | Value: 22. Result: `Ry` = `Ry + 22` (**197**). |
| **0015** | `OP_SUB` | `Ry` | Immediate subtraction from register `Ry`. |
| **0016** | (Data) | `0x0016` | Value: 22. Result: `Ry` = `Ry - 22` (**175**). |
| **0218** | `OP_COMPARE` | `Ry, Rz` | Compares `Ry` (175) with `Rz` (175). Result: Sets the **Z FLAG** (Zero) to 1. |
| **0024** | `OP_ADD` | `Rz` | Immediate addition to register `Rz`. |
| **0001** | (Data) | `0x0001` | Increments `Rz` by 1. Result: `Rz` = 176. |
| **0218** | `OP_COMPARE` | `Ry, Rz` | Compares `Ry` (175) with `Rz` (176). Result: Sets **NZ FLAG** (Non Zero). |
| **0002** | `OP_LOAD` | `Rx` | Loads an immediate value into register `Rx` (Counter Register). |
| **00B0** | (Data) | `0x00B0` | Value: 176. Result: `Rx` = 176. |
| **0009** | `OP_LABEL` | `-` | **Jump Label** (Start Loop). Saves the current PC. |
| **052C** | `OP_MOVE` | `Rc, Rz` | Moves the value from `Rz` to `Rc` (`Rc` = `Rz`). |
| **0024** | `OP_ADD` | `Rz` | Immediate addition to register `Rz`. |
| **00B0** | (Data) | `0x00B0` | Adds 176 to `Rz`. `Rz` = `Rz + 176`. |
| **0005** | `OP_SUB` | `Rx` | Immediate subtraction from register `Rx`. |
| **0001** | (Data) | `0x0001` | Decrements the loop counter. Result: `Rx` = `Rx - 1`. |
| **0308** | `OP_COMPARE` | `Rx, Ra` | Compares `Rx` with `Ra` (Ra = 0 by default). Checks the loop exit condition. |
| **0007** | `OP_JUMPNZ` | `-` | **Conditional Jump:** Jumps to the label address (`0009`) if the last comparison result was not Zero (i.e., if `Rx` > 0). |

---

## ğŸ‘¤ Author

**Raffaele Petrolo**
